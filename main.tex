\documentclass{article} % For LaTeX2e
\usepackage{iclr2020_conference,times}

% Optional math commands from https://github.com/goodfeli/dlbook_notation.
%\input{math_commands.tex}
\usepackage{amsmath,amsfonts,bm}

\usepackage{hyperref}
\usepackage{url}
\usepackage{breqn}
\usepackage{booktabs}
\usepackage{siunitx} % used in SHREC table
\usepackage{bbm}        % for mathbbm
\usepackage{graphicx} \graphicspath{{figures/}}
\usepackage[export]{adjustbox} % figure vertical alignment
\usepackage{subfig}
%\usepackage{wrapfig}
%\usepackage{floatflt}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

%\title{Which spherical CNN should you use?\\ DeepSphere V2}
\title{DeepSphere: a graph-based spherical CNN}
%\title{DeepSphere: an efficient graph-based spherical CNN}
%\title{DeepSphere, an efficient (& equivariant) graph-based spherical CNN}

\author{Michaël Defferrard, Martino Milani \& Frédérick Gusset \\
Institute of Electrical Engineering, EPFL, Lausanne, Switzerland \\
\texttt{\{michael.defferrard,martino.milani,frederick.gusset\}@epfl.ch}
\AND
Nathanaël Perraudin \\
Swiss Data Science Center (SDSC), Zurich, Switzerland \\
\texttt{nathanael.perraudin@sdsc.ethz.ch}
}

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{prop}{Proposition}
\newtheorem*{remark}{Remark}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\renewcommand{\b}[1]{{\bm{#1}}}  % bold symbol
\newcommand{\bO}{\mathcal{O}}
\newcommand{\R}{\mathbb{R}}
\renewcommand{\S}{\mathbb{S}}
\newcommand{\G}{\mathcal{G}}  % graph
\newcommand{\V}{\mathcal{V}}  % vertex set
\newcommand{\E}{\mathcal{E}}  % edge set
\DeclareMathOperator*{\diag}{diag}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\todo}[1]{{\color[rgb]{.6,.1,.6}{#1}}}
\newcommand{\nati}[1]{{\color[rgb]{.3,.5,.9}{#1}}}
\newcommand{\mart}[1]{{\color[rgb]{.9,.5,.3}{#1}}}

\newcommand{\figref}[1]{figure~\ref{fig:#1}}
\newcommand{\Figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\tabref}[1]{table~\ref{tab:#1}}
\newcommand{\Tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\secref}[1]{section~\ref{sec:#1}}
\newcommand{\Secref}[1]{Section~\ref{sec:#1}}
%\newcommand{\secref}[1]{\S\ref{sec:#1}}
\newcommand{\eqnref}[1]{equation~(\ref{eqn:#1})}
\newcommand{\Eqnref}[1]{Equation~(\ref{eqn:#1})}

\newcommand{\linefrac}[2]{
    {#1/#2}
}

%\iclrfinalcopy % Uncomment for camera-ready version, but NOT for submission.
\begin{document}

\begin{description}
	\item[git] \url{https://github.com/nperraud/deepsphere_v2_paper}
	\item[overleaf] \url{https://www.overleaf.com/project/5d31d2fbd6859d54cb707212}
\end{description}

\todo{
\begin{itemize}
	\item shall we really name it? Or simply reference the general idea of a graph-based spherical CNN.
	\item adjacency matrix: $A$ instead of $W$?
	\item anonymize DeepSphere citation
% 	\item climate spherical figure: inputs with TC and AR labels superimposed [Frédérick]
	\item citet for inline, citep for parenthesis
	\item More details on related work? Not sure we have the space. If yes, detailed comparison with related work after method.
	\item PSD of climate data: how does it compare to cosmo and 3D objects?
	\item align the spheres in figure 1
	\item mention that \citep{esteves2018sphericalcnn} and \citep{cohen2018sphericalcnn} computed equivariance error
	\item check footnotes
	\item climate data on spectrum plot
	\item result tables: only what supports the main message in the text, everything we have in the appendix
	\item Unify vocabulary. Sampling, discretization, or pixelization of the sphere? Signal, maps, functions. Irregular, uneven. Coarsening, down-sampling.
	\item check English vs American English
	\item unify enumerations. I like (i), (ii), etc.
	\item notation: should we use indices from 1 to n instead of 0 to n-1 for compactness?
	\item add \citet{bruna2013gnn} in equivariance? They were the first to do a spherical CNN with graphs. Graph is built from a uniform random sampling of the sphere.
	\item figure placements
	\item do the experiments on the icosahedral grid with the pooling as defined in the paper
	\item put all the code (learning experiments from Frédérick and equivariance experiments from Martino) in a common reproducible git repository to be linked from the paper
	\item update pygsp and merge sphere branch
	\item check that NN architectures and hyper-params are correctly reported
	\item keep NN architecture and hyper-params in the main text? Move the paragraph to appendix if not enough space.
	\item shall we still site adam and batch norm?
	\item check results on ModelNet40
\end{itemize}
}
\newpage

\maketitle

\begin{abstract}

story: there are tradeoffs when designing a spherical CNN -> DS strikes a controllable balance between efficiency / cost and exactitude / equivariance
% DSv2 has a clear tradeoff between equivariance and computational cost

* method development: tool that solve a need (balance btw the desiderata: equiv vs cost)\\
* research question: anisotropy (highlight from the start or leave it as a dangling question in the end)\\

contributions:\\
* theory $\Rightarrow$ convergence (better graph)\\
* experiments on relevant problems (not spherical MNIST) $\Rightarrow$ check the desiderata\\
  * surprising: anisotropy doesn't seem useful\\

Experiments on xxx show
Comparison with previous work on shape classification and climate event detection suggests that anisotropic filters are an unnecessary price to pay.
% memory, computations, implementation complexity

\end{abstract}

\section{Introduction}

Spherical data is found in many applications.
% spherical data f: S^2 -> R, projection from R^3
Planetary data (such as meteorological or geological measurements) and brain activity are example of intrinsically spherical data.
The observation of the universe, LIDAR scans, and the digitalization of 3D objects are examples of projections due to observation.
See \figref{examples}.
In many applications, labels or variables are to be inferred from spherical data.
Examples are the inference of cosmological parameters from the distribution of mass in the universe \citep{perraudin2019deepspherecosmo}, the segmentation of omnidirectional images \citep{khasanova2017sphericalcnn}, and the segmentation of cyclones from Earth observation \citep{mudigonda2017climateevents}.

\begin{figure}[h]
	\centering
	\subfloat[]{
		\includegraphics[height=0.20\linewidth,valign=t]{example_brain_meg}
	} \hspace{0.1em}
	\subfloat[]{
		\includegraphics[height=0.20\linewidth,valign=t]{example_cosmo_cmb}
	} \hfill
	\subfloat[]{
		\includegraphics[height=0.20\linewidth,valign=t]{example_climate_TMQ}
		\label{fig:examples:climate}
	} \hfill
	\subfloat[]{
		\includegraphics[height=0.20\linewidth,valign=t]{example_ghcn_daily_tmax}
		\label{fig:examples:ghcn:tmax}
	} \hfill
	\subfloat[]{
		\includegraphics[height=0.20\linewidth,valign=t]{example_ghcn_graph}
		\label{fig:examples:ghcn:graph}
	}
	\caption{
		Examples of intrinsically spherical data:
		(a) brain activity recorded through magnetoencephalography (MEG),\protect\footnotemark
		(b) the cosmic microwave background (CMB) temperature from \citet{planck2015overview},
		(c) hourly precipitation from a climate simulation \citep{jiang2019sphericalcnn}, %\citep{mudigonda2017climateevents},
		(d) daily maximum temperature from the Global Historical Climatology Network (GHCN).\protect\footnotemark
		A rigid full-sphere pixelization is not ideal: brain activity is only measured on the scalp, the Milky Way's galactic plane masks observations, climate scientists desire a variable resolution, and the position of weather stations is arbitrary and changes over time.
		(e) Graphs can faithfully and efficiently represent sampled spherical data by placing vertices where data has been measured.
		%\todo{something from climate, weather?}
		%\todo{compare ideal full-spheres (like SHREC-17 projection from Esteves, 360 from Coors) to real-world measurements?}
		%\todo{horizontal colorbar for brain}
	}
	\label{fig:examples}
\end{figure}
\footnotetext[1]{\scriptsize\url{https://martinos.org/mne/stable/auto_tutorials/plot_visualize_evoked.html}}
\footnotetext[2]{\scriptsize\url{https://www.ncdc.noaa.gov/ghcn-daily-description}}

% balance of ??
% Exploit the geometrical properties of the domain, symmetries.
% desiderata or tradeoff
% We identified the following desiderata for a spherical NN.
%Those take different tradeoffs among the following desiderata.
%\begin{enumerate}
%	\item \textbf{Respect the geometry.}  % geometry, domain
%		By respecting the domain, a spherical NN should respect the symmetries of the sphere, i.e., be equivariant to rotation, and not deform the sphere, e.g., by a projection on the icosahedron.
%	\item \textbf{Generality.} % powerful
%		How general the NN is as a function approximator.
%		For example, isotropic filters are less general than anisotropic filters.
%	\item \textbf{Scalability.}
%		How a spherical CNN scales w.r.t.\ the number of pixels in terms of computational cost and memory usage.
%		% memory: feature maps and parameters
%	\item \textbf{Flexibility.}
%		Whether the NN is constrained to work on specific samplings, part of the sphere (useful when data is masked), and irregular samplings.
%	\item \textbf{Simplicity.}
%		Simplicity of its derivation and implementation.
%\end{enumerate}

% keep the story simple and focus on the tradeoff between cost (time / computational and storage / memory) and exactitude
As neural networks (NNs) have proved to be great tools for inference, variants have been developed to handle spherical data.
Exploiting the locally Euclidean property of the sphere, early attempts used standard 2D convolutions on a grid discretization of the sphere \citep{boomsma2017sphericalcnn, su2017sphericalcnn, coors2018sphericalcnn}.
While simple and efficient, those convolutions are not equivariant to rotations.
On the other side of this tradeoff, \citet{cohen2018sphericalcnn} and \citet{esteves2018sphericalcnn} proposed to perform proper spherical convolutions through the spherical harmonic transform.
While equivariant to rotations, those convolutions are expensive.

% On the one side, we have Cohen which is computationally very expensive but perfectly equivariant most general, on the other we have cube sphere which computationl very good but not equivariant at all. Other methods are tradedoff between these two. What is a good tradeoff? We think that DeepSphere is.

As the lack of equivariance penalizes performance (\secref{exp:cosmo}) and expensive convolutions prohibit their application to some real-world problems, methods standing between those two extremes are desired.
\citet{cohen2019gauge} proposed to reduce costs by limiting the size of the representation of the symmetry group.
% (from the continuous rotation group SO(3) to a discrete rotation group)
% the dimensionality of feature maps is equal to the size of the irreducible representation of the symmetry group
%As a platonic solid, it \todo{exhibits discrete rotations}.
% the representation of its symmetry group is much smaller than SO(3)
\todo{not all rotations, subset of SO(3)?}
The projection of the data from the sphere to the icosahedron however introduces distortions that might hinder performance (see the experiments in \secref{exp:climate}).
\todo{Where does Jiang fit? Need a global coordinate system (ok for planets, not projections like cosmo)}

Another approach represents the discretized sphere as a graph connecting pixels according to the distance between them \citep{bruna2013gnn, khasanova2017sphericalcnn, perraudin2019deepspherecosmo}.
While Laplacian-based graph convolutions are more efficient than spherical convolutions, they are not exactly equivariant \citep{defferrard2019deepsphereequiv}.
In this work, we argue that graph-based spherical CNNs strike an interesting balance, with a controllable tradeoff between cost and equivariance.
Experiments on multiple problems of practical interest show the competitiveness and flexibility of this approach.
% Furthermore, experiments show that, perhaps surprisingly and contrarily to previously published results \citep{cohen2019gauge} \todo{[Bronstein?]}, anisotropic filters might be an unnecessary price to pay.
% This paper focuses on improving the rotation equivariance of \citet{perraudin2019deepspherecosmo}, a scalable graph-based method designed for cosmological applications.

\section{Method [1 pages]}

% \begin{figure}
% 	\centering
% 	\includegraphics[width=\linewidth]{figure_architecture_v3}
% 	\caption{Example architecture from \cite{perraudin2019deepspherecosmo}.
% 		Global tasks need a spatial summarization: the FCN variant is rotation invariant (and accepts inputs of varying sizes), while the CNN variant is not.
% 		Dense tasks (when the output lives on the sphere, like segmentation) are rotation equivariant.
% 		\todo{Shall we keep this figure? It's very nice, but we could save space. ML people probably have this in mind.}
% 	}
% 	\label{fig:architecture}
% \end{figure}

DeepSphere leverages graph convolutions to achieve the following properties: (i) computational efficiency, (ii) sampling flexibility, and (iii) rotation equivariance (\secref{equivariance}).
% An example architecture is shown in \figref{architecture}.
The main idea is to model the discretized sphere as a graph of connected pixels: the length of the shortest path between two pixels is an approximation of the geodesic distance between them.
We use the graph CNN formulation introduced in \citep{defferrard2016graphnn}, and a pooling strategy that exploits hierarchical pixelizations of the sphere.

\paragraph{Sampling.}
Given a sampling scheme $\V = \{x_i \in \S^2\}_{i=1}^n$, a function $f : \S^2 \supset F_\V \to \R$ is sampled as $T_\V(f) = \b{f}$ by the sampling operator $T_\V: L^2(\S^2) \supset F_\V \to \R^n$ defined as $\b{f}: f_i=f(x_i)$, where $F_\V$ will be specified in \secref{equivariance}.
As there is no analogue of uniform sampling on the sphere, many schemes have been proposed with different tradeoffs.
In this work, depending on the considered application, we will use the equiangular \citep{driscoll1994Fouriersphere}, HEALPix \citep{gorski2005healpix}, and icosahedral \citep{baumgardner1985icosahedral} grids.

\paragraph{Graph.}
From $\V$, we construct a weighted undirected graph $\G = (\V, w)$, where the elements of $\V$ are the vertices and the weight $w_{ij} = w_{ji}$ is a similarity measure between vertices $x_i$ and $x_j$.
The combinatorial graph Laplacian $\b{L} \in \R^{n \times n}$ is defined as $\b{L} = \b{D} - \b{A}$, where $\b{A} = (w_{ij})$ is the weighted adjacency matrix, $\b{D} = (d_{ii})$ is the diagonal degree matrix, and $d_{ii} = \sum_j w_{ij}$ is the weighted degree of vertex $x_i$.
%$\b{D} = \diag(\b{A} \b{1})$
Given a sampling scheme $\V$, usually fixed by the application or the available measurements, the only freedom in constructing $\G$ is in setting $w$.
\Secref{equivariance} shows how to set $w$ to minimize the equivariance error.
%building a good graph amounts to set a good $w$.

\paragraph{Convolution.}
On Euclidean domains, convolutions are efficiently implemented by sliding a window in the signal domain.
On the sphere however, there is no straightforward way to implement a convolution in the signal domain due to non-uniform samplings.
Convolutions are most often performed in the spectral domain through a spherical harmonic transform (SHT).
That is the approach taken by \citet{cohen2018sphericalcnn} and \citet{esteves2018sphericalcnn}, which has a computational cost of $\bO(n^{3/2})$ on isolatitude pixelizations (such as the HEALPix and equiangular grids) and $\bO(n^2)$ in general.
On the other hand, following \citet{defferrard2016graphnn}, graph convolutions can be defined as
\begin{equation} \label{eqn:graph_conv}
	h(\b{L}) \b{f} = \left(\sum_{i=0}^K \alpha_i \b{L}^i\right) \b{f},
\end{equation}
where $K$ is the polynomial order (which corresponds to the filter's size) and $\alpha_i$ are the coefficients to be optimized during training.\footnote{In practice, training with Chebyshev polynomials (instead of monomials) is slightly more stable. We believe it to be due to their orthogonality and uniformity.}
Those convolutions are used by \citet{khasanova2017sphericalcnn} and \citet{perraudin2019deepspherecosmo} and cost $\bO(n)$ operations through a recursive application of $\b{L}$.\footnote{As long as the graph is sparsified such that the number of edges, i.e., the number of non-zeros in $\b{A}$, is proportional to the number of vertices $n$. This can always be done as most weights are very small.}

\paragraph{Pooling.}
Down- and up-sampling is natural for hierarchical pixelizations,\footnote{The equiangular, HEALPix, and icosahedral schemes are of this kind.} where each subdivision divides a pixel in (an equal number of) child sub-pixels.
To pool (down-sample), the data supported on the sub-pixels is summarized by a permutation invariant function such as the maximum or the average.
To unpool (up-sample), the data supported on a pixel is copied to all its sub-pixels.
% Frédérick: Dans le cas de l'icosahedron, le pooling n'est pas invariant à la permutation (on prend la valeur du 1er pixel, sans regarder les autres)
% Frédérick: Et le unpooling est correct uniquement dans le cas de l'average pooling (mais on fait pas de max pooling dans ce cas). Encore une fois, l'icosahedron est inspiré de Jiang, où 1 seul sub-pixel prend la valeur du pixel, le reste est rempli avec des '1'

\paragraph{Architecture.}
All our NNs are fully convolutional, and employ a global average pooling (GAP) for rotation invariant tasks.
Graph convolutional layers are always followed by batch normalization \citep{ioffe2015batchnorm} and ReLU activation, except in the last layer.
Note that batch normalization and activation act on the elements of $\b{f}$ independently, and hence don't depend on the domain of $f$.
%We denote graph convolutional layers with $C$ output channels as $GC_C$ and fully connected layers with $C$ output neurons as $FC_C$.
%Those linear layers are always followed by batch normalization and ReLU activation, except in the last layer.
%softmax normalization as $SM$
%Pooling and unpooling by a factor $F$ are denoted as $P_F$ and $P^{-1}_F$, global average pooling as $GAP$.

% \section{Notation}
% Throughout this contribution, we denote with bold font all vectors and matrices such as $\b{L}$ the graph Laplacian and $\b{f}$ the vector of the sampled function $f$.
% \nati{Right now, it is not True}
% % , a weighted undirected graph $G(V, E, \mathbf W)$,
% \nati{I do not think we should have a notation section, but should somehow write this somewhere...}
% mdeff: I think this convention is clear enough when reading.

\section{Graph convolution and equivariance [2 pages]} \label{sec:equivariance}
%\section{Is graph convolution equivariant to rotation? [2 pages]} \label{sec:equivariance}

While the graph framework offers great flexibility, its ability to faithfully represent the underlying sphere --- for graph convolutions to be rotation equivariant --- highly depends on the sampling locations and the graph construction.

\subsection{Problem formulation}
% 0.1 Explain the sampling problem
%As the graph convolution acts on a sampled version of the function $\b{f}$ and the rotation on its continuous counterpart $f$, a sampling operator is needed.

We require $F_\V$ to be a suitable subspace of $L^2(\S^2)$ such that $T_\V$ is invertible, i.e., the function $f \in F_\V$ can be unambiguously reconstructed from its sampled values $\b{f}$.
The existence of such a subspace depends on the sampling scheme $\V$, and its characterization is a common problem in signal processing \citep{driscoll1994Fouriersphere}.
For most sampling schemes, it is not known if $F_\V$ exists and hence if $T_\V$ is invertible.
A special case is the equiangular sampling scheme where a sampling theorem holds, and thus a closed form of $T_\V^{-1}$ is known. % \cite{driscoll1994Fouriersphere}
For sampling schemes where no such sampling formula is available, we leverage the discrete SHT to reconstruct $f$ from $\b{f}$, thus approximating $T_\V^{-1}$.
For all theoretical considerations, we assume that $F_\V$ exists and $f \in F_\V$.

% 0.2 Explain why the Laplacian is so important...
By definition, our (spherical) graph convolution is rotation equivariant, if and only if, it commutes with the rotation operator defined as $R(g), g\in SO(3)$: $R(g) f(x) = f\left(g^{-1} x \right)$.
In the context of this work, graph convolution is performed by recursive applications of the graph Laplacian (\eqnref{graph_conv}).
Hence, if $\b{L}$ commutes with the rotation operator, then, by recursion, it will also commute with the convolution $h(\b{L})$.
As a result, to simplify our analysis, we concentrate on the graph Laplacian and $h(\b{L})$ is rotational invariant if and only if
% 0.3 Formulate the problem
\mart{Correct formula for equivariance error and the corresponding plots as soon as you changed it!}
\begin{equation} \label{eq:equivariance}
	\b{R}_\V(g) \b{L} \b{f} = \b{L} \b{R}_\V(g) \b{f} \hspace{1cm} \forall f\in F_\V \text{ and } \forall g\in SO(3),
\end{equation}
where $\b{R}_\V(g) = T_\V R(g) T_\V^{-1}$. For practical a evaluation of the equivariance, we define the \textit{normalized equivariance error} for a signal $\b{f}$, and a  rotation $g$ as:
\begin{equation} \label{eq:equivariance error}
	E_{\b{L}}(\b{f}, g) = \left(\frac{ \norm {\b{R}_\V(g) \b{L} \b{f} - \b{L} \b{R}_\V(g) \b{f}} }{\norm {\b{L} \b{f}}}\right)^2,
\end{equation}
More generally for a class of signal $f \in C \subset F_\V$, the \textit{mean equivariance error}
\begin{equation} \label{eq:mean equivariance error}
	\overline E_{\b{L}, C} = \mathbb E_{\b{f}\in C, g\in SO(3)} \ E_{\b{L}}(\b{f}, g).
\end{equation}
\mart{Talk about the probability measure used on C, SO(3)?}
In practice, to analyze the equivariance error frequency,  the set $C$ we used is composed of functions $f$ made of spherical harmonic of a single degree $\ell$.
The expected value is obtained by averaging over a finite number of random functions and random rotations.

\subsection{Finding the optimal set of weights}  \label{sec:optimal}

% 1) summary the work of Khasanova
\cite{khasanova2017sphericalcnn} designed a Laplacian $\b{L}$ explicitly intended to work with the equiangular sampling.
They consider the set $\mathcal{G}$ of all the possible graphs where each node is connected only to four of its nearest neighbours (North, Sud, West, East) and propose a weighting scheme $w_{ij}$ that minimizes \eqref{eq:equivariance error} for specific rotations on the longitude latitude axis.
Their approach leads to weights $w_{ij}$ inversely proportional to the Euclidean distance between vertices:
\begin{equation} \label{eqn:weights:khasanova}
	w_{ij} = \frac{1}{\norm{x_i-x_j}}
\end{equation}

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{kernel_widths}
	\caption{
		Optimal kernel widths for various resolutions of the HEALPix grid.
	}
	\label{fig:kernel_widths}
\end{figure}

% 2) explain our approach
We chose a different approach and take inspiration from \cite{belkin2005towards}, which proves that for a random \emph{uniform sampling} scheme the graph Laplacian converges toward the Laplace-Beltrami operator $\Delta_{\mathbb{S}^2}$ as the number of sampling points goes to infinity.
This convergence result is important as a) $\Delta_{\mathbb{S}^2}$ commutes with rotation ($\Delta_{\mathbb{S}^2}R(g) = R(g)\Delta_{\mathbb{S}^2}$) and b) is diagonalized by the spherical harmonics.
In this case the weighting scheme is full (every node is connected to every node) and is based on the exponential kernel:
\begin{equation} \label{eqn:weights:belkin}
w_{ij} = e^{-\frac{1}{4t} \norm{x_i-x_j}^2}
\end{equation}
In practice most of the weights are very close to $0$ and hence, to optimize for computational efficiency, we limit ourselves to only the $k$ nearest neighbors.
Given $k$, the optimal $t$ is found by searching for the minimizer of \eqref{eq:mean equivariance error}.
\Figref{kernel_widths} shows the optimal kernel widths found for various resolutions of the HEALPix grid.

\subsection{Analysis of the proposed weighting scheme}
We analyse our proposed weighting scheme both theoretically and empirically.

\paragraph{Theoretical convergence.}
We extend the work of Belkin and Nyiogi to a sufficiently regular, deterministic sampling scheme.
Given a sampling scheme $V = \{x_0, \dots, x_{n-1}\}$, define $\sigma_i$ to be the patch of the surface of the sphere corresponding to $x_i$, define $A_i$ to be its corresponding area and $d_i$ to be the radius of the smallest ball in $\R^3$ containing $\sigma_i$. Define $d^{(n)} := \max_{i=0, \dots, n}d_i$ and $A^{(n)}=\max_{i=0, \dots, n}A_i$.
\begin{theorem}
	For a sampling $V = \{x_i\in\S^2\}_{i=0}^{n-1}$ of the sphere that is equi-area and such that $d^{(n)} \leq \frac{C}{\sqrt{n}}$, for all $f: \S^2 \rightarrow \R$ Lipschitz with respect to the Euclidean distance in $\R^3$, for all $y\in\S^2$, there exists a sequence $t_n = n^\beta$ such that the rescaled Heat Kernel Graph Laplacian $\frac{|\S^2|}{4\pi t_n^2}\b {L}^t_n$ converges pointwise to the Laplace Beltrami operator on the sphere $\Delta{\S^2}$  for $n\to\infty$:
	\begin{equation*}
	 \lim_{n\to\infty} \frac{|\mathbb{S}^2|}{4\pi t_n^2} \b{L}_n^{t_n} T_V f [i] =  \Delta_{\mathbb{S}^2}f(x_i)\quad \forall i=0, ..., n-1.
	\end{equation*} 
	\label{theo:pointwise convergence for a regular sampling}
\end{theorem}
This theorem implies immediately that $\b{L}$ converges pointwisely toward an operator ($\Delta_{\S^2}$) commuting with rotation and hence is a strong hint for equivariance.
Importantly, the proof of Theorem \ref{theo:pointwise convergence for a regular sampling} in Appendix \ref{sec: appendix: proof of theorem} inspires us in the construction of our graph Laplacian. It gives us a strong hint how the parameter $t$ needs to be adjusted with respect to the number of points $n$.

It is important to keep in mind the limits of Theorem \ref{theo:pointwise convergence for a regular sampling}.
First, it is \emph{not} a proof of equivariance of the graph convolution for a specific sampling. To construct such a proof, a stronger convergence result is needed, for example uniform convergence (instead of pointwise).
\todo{Can we intuitively write what pointwise convergence means, and how it is more limited than spectral or uniform convergence?}
Unfortunately, the graph laplacian does \emph{not} converges uniformly in general \cite{belkin2007convergence}. This can probably be overcome by considering a specific class of functions, such as bandlimited function.
Second, while do not have a proof for it, we strongly believe that the HEALPix sampling does satisfy the hypothesis $d^{(n)}\leq \frac{C}{\sqrt{n}}$ of Theorem \ref{theo:pointwise convergence for a regular sampling}. This is discussed in Appendix \ref{sec: appendix: proof of theorem}.


% 3) Show experimental results
\paragraph{Empirical convergence.}

% 3.0) explain how we obtained the figures
We calculated numerically the equivariance error (\ref{eq:mean equivariance error}) by generating $N$ monochromatic signals and $M$ random rotations for each signal. The colors that were used were chosen in the range $(0,\  3N_{side}-1)$ to allow for an almost perfect synthesis of the rotated signals, and thus an almost perfect implementation (up to numerical errors) of the operator $\b{R}_\V$ \citep{gorski1999healpixprimer}.

% 3.1) explain what the figures tell us
From 20\% error on V1, we got to less than 2\% error on V2. The number of neighbors used for V2 is $50$. More neighbors implies naturally more precision, plus a better kernel width obtained by "minimizing" the equivariance error. \mart{How to explain how we found the kernel width? Micha\"el I need your help here!!} Literally, minimizing the kernel width would lead to a completely disconnected graph. What we did was finding a heuristic law (fix neighbors, set the kernel width $\hat t$ by imposing the minimum weight to be equal to $0.1$) and then minimizing the equivariance error in the range $(\hat t / 10, \hat t\cdot 10) $. We got better that Khasanova-Frossard \mart{(check the code)} that however uses only 4 neighbors. However, it is built to explicitely minimize the equivariance error, so we expect it to be a good benchmark against which to test our construction.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{DeepSphereV1}
	\caption{Shall we put it here or in Appendix?
	}
	\label{fig:deepsphereV1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{DeepSphereV2_50neighbors.pdf}
	\caption{}
	\label{fig:deepsphereV2}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{khasanova_frossard.pdf}
	\caption{}
	\label{fig:khasanova_frossard}
\end{figure}


\section{Experiments [2 pages]}

% Show:
% * meet the desiderata: scale
% * DeepSphere V1 and V2 are equivalent in practice: better equivariance doesn't translate to better performance
% * anisotropy doesn't help

\subsection{3D objects recognition} \label{sec:exp:objects}

\begin{figure}
%\begin{floatingfigure}[r]{0.5\linewidth}
%\begin{wrapfigure}{r}{0.5\linewidth}
	\begin{minipage}[t]{0.57\linewidth}
		\centering
		\includegraphics[height=7em]{lamp_000018}
		\hfill
		\includegraphics[height=7em]{lamp_000018_sphere_nobar}
		\caption{Example of a 3D object from SHREC'17 represented as a spherical depth map.}
		\label{fig:depthmap}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.35\linewidth}
		\centering
		\includegraphics[height=7em]{spectrum}
		\caption{Power spectral densities.}
		\label{fig:spectrum}
	\end{minipage}
%\end{wrapfigure}
%\end{floatingfigure}
\end{figure}

The recognition of 3D shapes is a rotation invariant task: rotating an object doesn't change its nature.
While 3D shapes are usually represented as meshes or point clouds, representing them as spherical maps (\figref{depthmap}) naturally allows a rotation invariant treatment.
LIDAR actually acquires depth maps, which are a posteriori represented as point clouds.
\todo{move to intro?}

The SHREC'17 shape retrieval contest \citep{shrec17} contains 51,300 randomly oriented 3D models from ShapeNet \citep{shapenet}, to be classified in 55 categories (tables, lamps, airplanes, etc.).
As in \citet{cohen2018sphericalcnn}, objects are represented by 6 spherical maps.
At each pixel, a ray is traced towards the center of the sphere.
The distance from the sphere to the object forms a depth map.
The $\cos$ and $\sin$ of the surface angle forms two normal maps.
The same is done for the object's convex hull.\footnote{Albeit we didn't observe much improvement by using the convex hull.}
The maps are discretized using either an equiangular grid with bandwidth $b = 64$ ($n = 4 b^2 = 16,384$ pixels) or an HEALPix grid with $N_{side} = 32$ ($n = 12 N_{side}^2 = 12,288$ pixels).

The equiangular graph is built with \eqnref{weights:khasanova} and $k = 4$ neighbors \citep[following][]{khasanova2017sphericalcnn}.
\todo{The HEALPix graph is built with \eqnref{weights:belkin}, $k = ?$ and the corresponding optimal kernel width $t = ?$.}
\todo{Following Esteves or Cohen?}
The NN is made of $5$ graph convolutional layers, each followed by a \todo{max?} pooling layer down-sampling by $4$.
A GAP and a fully connected layer with softmax follow.
The Chebyshev polynomials are all of order $K=4$ and the number of channels per layer is $16, 32, 64, 128, 256$, respectively.
Following \citet{esteves2018sphericalcnn}, the cross-entropy plus a triplet loss is optimized with Adam \citep{kingma2014adam} for 30 epochs on the dataset augmented by 3 random translations.
The learning rate is $5 \cdot 10^{-2}$ and the batch size is 32.

\begin{table}
    \centering
	%\begin{tabular}{l cc r rr}
	\begin{tabular}{l cc r rS[table-format=2.0]}
		\toprule
		& \multicolumn{2}{c}{performance} & \multicolumn{1}{c}{size} & \multicolumn{2}{c}{speed} \\
		\cmidrule(lr){2-3} \cmidrule(lr){4-4} \cmidrule(lr){5-6}
		& F1 & mAP & params & \multicolumn{1}{c}{inference} & \multicolumn{1}{c}{training} \\
		\midrule
		% $SO(3)$ vs $S^2$ vs graph
		\citet{cohen2018sphericalcnn} ($b=128$) & - & 67.6 & 1400\,k & 38.0\,ms & 50\,h \\
		\citet{cohen2018sphericalcnn} (simplified,\protect\footnotemark $b=64$) & 78.9 & 66.5 & 400\,k & 12.0\,ms & 32\,h \\
		\citet{esteves2018sphericalcnn} ($b=64$) & 79.4 & 68.5 & 500\,k & 9.8\,ms & 3\,h \\
		DeepSphere (equiangular $b=64$) & 79.4 & 66.5 & 190\,k & 0.9\,ms & 50\,m \\
		DeepSphere (HEALPix $N_{side}=32$) & 80.7 & 68.6 & 190\,k & 0.9\,ms & 50\,m \\
		\bottomrule
	\end{tabular}
    \caption{
		Results on SHREC'17 (3D shapes): DeepSphere achieves similar performance at a much lower cost, suggesting that anisotropic filters are an unnecessary price to pay.
		% F1-score computed with sklearn, mAP from the official script of the competition.
		% inference speed = time for a single instance to do a single training pass
		% training speed = time for the neural net to train to peak performance
	}
    \label{tab:shrec17}
\end{table}
\footnotetext[5]{As implemented in \url{https://github.com/jonas-koehler/s2cnn}.}

Results are shown in \tabref{shrec17}.
DeepSphere achieves the same performance as \citet{cohen2018sphericalcnn} and \citet{esteves2018sphericalcnn} at a much lower cost, suggesting that anisotropic filters are an unnecessary price to pay.
% x times faster
As the information in those spherical maps resides in the low frequencies (\figref{spectrum}), reducing the equivariance error didn't translate into improved performance.
For the same reason, using the more uniform HEALPix discretization or lowering the resolution down to $N_{side} = 8$ didn't impact performance.
\todo{be sure that it fits with the cosmo conclusion}
\todo{The same conclusions are drawn from ModelNet 40 (see appendix ??).}

% Limited by representation of data? yep, treat them as point clouds

\subsection{Cosmological model classification} \label{sec:exp:cosmo}

Given observations, cosmologists estimate the posterior probability of cosmological parameters, such as the matter density $\Omega_m$ and the normalization of the matter power spectrum $\sigma_8$.
Those parameters are typically estimated by likelihood-free inference, which requires a function to predict the parameters from simulations.
% such as Approximate Bayesian computation (ABC)
As that is complicated to setup, prediction methods are typically benchmarked on the classification of spherical maps into cosmological model classes \citep{schmelze2017cosmologicalmodel}.
We used the same task, data, and setup as \citet{perraudin2019deepspherecosmo}: the classification of $720$ partial convergence maps made of $n \approx 10^6$ pixels ($1/12 \approx 8\%$ of a sphere at $N_{side} = 1024$) from two $\Lambda$CDM cosmological models, ($\Omega_m = 0.31$, $\sigma_8 = 0.82)$ and ($\Omega_m = 0.26$, $\sigma_8 = 0.91)$, at a relative noise level of $4$.
% 60 maps * 12 parts = 720 parts
Convergence maps represent the distribution of over- and under-densities of mass in the universe \citep[see][for a review of gravitational lensing]{bartelman2010gravitationallensing}.

Graphs are built with \eqnref{weights:belkin}, $k = 8, 20, 40$ and the corresponding optimal kernel widths $t = ?, ?, ?$.
Following \citet{perraudin2019deepspherecosmo}, the NN is made of $5$ graph convolutional layers, each followed by a \todo{max?} pooling layer down-sampling by $4$.
A GAP and a fully connected layer with softmax follow.
The Chebyshev polynomials are all of order $K=5$ and the number of channels per layer is $16, 32, 64, 64, 64$, respectively.
The cross-entropy loss is optimized with Adam for 80 epochs.
The learning rate is $2 \cdot 10^{-4} \cdot 0.999^{\textrm{step}}$ and the batch size is 8.

\begin{table}
    \centering
    \begin{tabular}{l c c c}
		\toprule
		& accuracy & conv. equiv. error & NN inv. error \\
		\midrule
		2D CNN baseline \citep{perraudin2019deepspherecosmo} & \todo{??} & \todo{can we?} \\
		8 neighbors, $\hat{t} = ??$, CNN variant, \citep{perraudin2019deepspherecosmo} & \todo{??} & \todo{??} \\
		8 neighbors, $\hat{t} = ??$, FCN variant, \citep{perraudin2019deepspherecosmo} & \todo{??} & \todo{??} \\
		8 neighbors, optimal kernel width $\hat{t} = ??$ & \todo{??} & \todo{??} \\
		20 neighbors, optimal kernel width $\hat{t} = ??$ & \todo{??} & \todo{??} \\
		40 neighbors, optimal kernel width $\hat{t} = ??$ & \todo{??} & \todo{??} \\
		\bottomrule
    \end{tabular}
	\caption{
		Results on the classification of partial convergence maps.
		\todo{While extreme non-equivariance (the 2D CNN baseline) penalizes performance, improving equivariance doesn't improve performance.}
	}
    \label{tab:cosmo}
\end{table}

\todo{
}

Results are shown in \tabref{cosmo}.
\todo{
	While extreme non-equivariance (the 2D CNN baseline) penalizes performance, better equivariance doesn't improve performance.
	It might be that the lack of built-in equivariance is compensated by learned equivariance (as done when augmenting data during training).}
\todo{
	Alternative: DSv2 better than v1 -> equivariance has practical implications.
	Clear cost-accuracy tradeoff with the number of neighbors.
}
This experiment moreover demonstrates DeepSphere's flexibility (using partial spherical maps) and scalability (competing spherical CNNs were tested on maps of at most $10,000$ pixels).

\subsection{Climate event segmentation} \label{sec:exp:climate}

We evaluate our method on a task proposed by \citep{mudigonda2017climateevents}: the segmentation of extreme climate events, Tropical Cyclones (TC) and Atmospheric Rivers (AR), in global climate simulations (\figref{examples:climate}).
The data was produced by a 20-year run of the Community Atmospheric Model v5 (CAM5) and consists of 16 channels such as temperature, wind, humidity, and pressure at multiple altitudes.
We used the pre-processed dataset from \citep{jiang2019sphericalcnn}.\footnote{Available at \url{http://island.me.berkeley.edu/ugscnn/data}.}
%\url{https://github.com/maxjiang93/ugscnn}
%\url{https://github.com/maxjiang93/ugscnn/blob/master/experiments/exp4_sphere_climate/run.sh}
%\url{http://island.me.berkeley.edu/ugscnn/data/climate_sphere_l5.zip}
There is 1,072,805 spherical maps, down-sampled to a level-5 icosahedral grid ($n = 10 \cdot 4^l + 2 = 10,242$ pixels).
The labels are heavily unbalanced with 0.1\% TC, 2.2\% AR, and 97.7\% background (BG) pixels.

The graph is built with \eqnref{weights:belkin}, \todo{$k = ?$} and the \todo{corresponding optimal kernel widths $t = ?, ?, ?$}.
Following \citet{jiang2019sphericalcnn}, the NN is an encoder-decoder with skip connections.
Details in \secref{climate:appendix}.
%The encoder is made of $5$ graph convolutional layers, each followed by a \todo{pick-one?} pooling layer down-sampling by $4$.
%the number of channels per layer is $16, 32, 64, 64, 64$, respectively.
%The decoder is made of
The Chebyshev polynomials are all of \todo{order $K=5$}.
The cross-entropy loss (weighted or non-weighted) is optimized with Adam for 30 epochs.
The learning rate is $1 \cdot 10{-3}$ and the batch size is 64.

\begin{table}
	\centering
	\begin{tabular}{l l l}
	\toprule
	& accuracy & mAP \\
	\midrule
	%\cite{jiang2019sphericalcnn} (paper) & 94.67 & - \\
	\cite{jiang2019sphericalcnn} (rerun) & 94.95 & 38.41 \\
	\cite{cohen2019gauge} (S2R) & 97.5 & 68.6 \\
	\cite{cohen2019gauge} (R2R) & 97.7 & 75.9 \\
	DeepSphere (weighted loss) & $97.8\pm 0.3$ & $77.15\pm 1.94$ \\
	DeepSphere (non-weighted loss) & $87.8\pm 0.5$ & $89.16\pm 1.37$ \\
	\bottomrule
	\end{tabular}
	\caption{
		Climate event segmentation results: mean accuracy (over TC, AR, BG) and mean average precision (over TC and AR).
		DeepSphere achieves state-of-the-art performance. %, suggesting again that anisotropic filters are an unnecessary price to pay.
	}
	\label{tab:climate}
\end{table}

Results are shown in \tabref{climate} (details in tables~\ref{tab:climate:accuracy}, \ref{tab:climate:map} and~\ref{tab:climate:speed}).
The mean and standard deviation are computed over 5 runs.
Note that while \citet{jiang2019sphericalcnn} and \citet{cohen2019gauge} use a weighted cross-entropy loss, it is not ideal for the mAP metric.
Results from \citet{mudigonda2017climateevents} cannot be directly compared as they don't use the same input channels.
DeepSphere achieves state-of-the-art performance, suggesting again that anisotropic filters are unnecessary.

Compared to \citet{cohen2019gauge}'s conclusion, it is surprising that S2R does worse than DeepSphere (which is limited to S2S).
Potential explanations are (i) that their icosahedral projection introduces harmful distortions, or (ii) that a larger architecture can compensate for the lack of generality. % powerfulness?
We indeed observed that more feature maps and depth led to higher performance (\secref{climate:appendix}).

\subsection{Uneven sampling} \label{sec:exp:ghcn}
% Weather prediction? But it's not a real task. Rather a demo.

To demonstrate the flexibility of modeling the discretized sphere by a graph, we collected historical measurements from about $n = 10,000$ weather stations scattered across the Earth.\footnote{\url{https://www.ncdc.noaa.gov/ghcn-daily-description}}
The spherical data is heavily non-uniformly sampled, with a much higher density of weather stations over North America than the Pacific (\figref{examples:ghcn:tmax}).
For illustration, we devised two artificial tasks.
A dense regression that consists of predicting the temperature on a given day knowing the temperature on the 5 previous days.
A global regression that consists of predicting the day (represented as one period of a sine over the year) from temperature or precipitations.

The graph is built with \eqnref{weights:khasanova} and \todo{$k = ?$} neighbors.
The kernel width $t$ is set as the average of the distances.
The equivariance property of the resulting graph has not been tested, and we don't expect it to be good due to the heavily non-uniform sampling.
The NN is made of $3$ graph convolutional layers.
The Chebyshev polynomials are all of order $K=0$ or $4$ and the number of channels per layer is $50, 100, 100$, respectively.
For the global regression, a GAP and a fully connected layer follow.
For the dense regression, a graph convolutional layer follows instead.
The MSE loss is optimized with RMSprop for 250 epochs.
The learning rate is $1 \cdot 10^{-3}$ and the batch size is 64.

\begin{table}
    \centering
    \begin{tabular}{
			c
			S[table-format=2.2]
			S[table-format=1.2]
			S[table-format=1.3]
			S[table-format=1.2]
			S[table-format=1.2]
			S[table-format=1.3]
			S[table-format=1.2]
			S[table-format=1.2]
			S[table-format=-1.3]
		}
		\toprule
		& \multicolumn{3}{c}{temp. (from past temp.)} & \multicolumn{3}{c}{day (from temperature)} & \multicolumn{3}{c}{day (from precipitations)} \\
		\cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-10}
		order $K$ & {MSE} & {MAE} & {R2} & {MSE} & {MAE} & {R2} & {MSE} & {MAE} & {R2} \\
		\midrule
		$0$ & 10.88 & 2.42 & 0.896 & 0.10 & 0.10 & 0.881 & 0.58 & 0.42 & -0.920 \\
		%%$1$ &  8.91 & 2.20 & 0.906 & - & - & - & - & - & - \\
		$4$ &  8.20 & 2.11 & 0.919 & 0.05 & 0.06 & 0.969 & 0.50 & 0.18 &  0.597 \\
		%$9$ &  8.38 & 2.12 & 0.915 & - & - & - & - & - & - \\
		\bottomrule
    \end{tabular}
    \caption{
		Prediction results on data from weather stations.
		Structure always helps.
	}
    \label{tab:ghcn}
\end{table}

Results from \tabref{ghcn} show that treating the times series as a time-varying spherical signal (with filters of polynomial order $K>0$) yields higher performance than treating each time series independently ($K=0$).
Note that predicting the day from temperature is much easier as temperature has a yearly pattern.
Still, structure helps.

% * increasing order is good until threshold \\
% * equivariance to be verified in this case (next paper) -> in conclusion \\
% * The NN indeed predicts the correct temperature at day T, and not day T-1 (baseline) even though there is small difference. \\
% * \todo{performance of baseline} \\

\section{Conclusion [0.5 pages]}

This work showed that DeepSphere strikes an interesting balance between desiderata for a spherical CNN.
A single parameter, the number of neighbors a pixel is connected to in the graph, controls the tradeoff between \todo{performance and efficiency}.
% vague words
As computational cost and memory consumption scales linearly with the number of pixels, DeepSphere easily deals with spherical maps made of millions of pixels.
Such high resolutions are not necessary to represent the depth maps of 3D objects, but are required to faithfully represent cosmological and climate data.
% That has to do with the frequency content of the signals (see fig xx)
% cannot do better
Also relevant in scientific applications is the flexibility offered by a graph representation to deal with partial coverage and non-uniform samplings.
% partial coverage / missing data
Finally, the implementation of Laplacian-based graph convolutions is straightforward.
The ubiquity of graph neural networks, pushing for a first-class support in Deep Learning frameworks, will make implementations even easier and more efficient.

A potential drawback of graph Laplacian-based approaches is that graph filters are isotropic, reducing the expressive power of the NN.
% in principle -> may in fact not
% Our experiments showed that DeepSphere nonetheless achieved state-of-the-art performance, on par with methods featuring anisotropic filters.
% didn't hurt perf in any experiment
% expressive power / generality / powerful / function approximator
%Why anisotropic filters?
Experiments from \citet{cohen2019gauge} suggest that more general convolutions achieve better performance.
Our climate experiments (\secref{exp:climate}) however show that DeepSphere achieves similar performance than their most general convolution.
% the SHREC17 experiment too shows that isotropic filters are sufficient
Works on shape alignment indicates that anisotropic filters achieve better performance \todo{[Bronstein]}.
Possible explanations for this discrepancy are that NNs somehow compensate for the lack of anisotropic filters, or that some tasks can be solved with isotropic filters.
% why: icosahedron, can do anisotropy with isotropy + non-linearity + pooling
The distortions induced by the icosahedral projection in \citep{cohen2019gauge} or the leakage of curvature information in \todo{[Bronstein]} might also be explanations.
Further research is needed to determine if anisotropic filters are an unnecessary price to pay or if they are needed for some applications.
% As was recently shown for graph NNs used for graph classification, most general might not be the best, when the ultimate goal is generalization [Andreas paper? + previous by xx]

Developing graph convolutions on irregular samplings that still respect the geometry of the sphere is another research direction of importance.
% known underlying manifold
Practitioners currently interpolate their measurements (coming from arbitrarily positioned weather stations, satellites or telescopes) to regular samplings.
This practice either results in a waste of precision or computational and storage resources.
Our ultimate goal is for practitioners to be able to work directly on their measurement, however distributed.

% beyond the sphere => any manifold
% what are other manifolds of interest?
% done by monet & co on shapes

% beyond scalar fields => simplicial complexes

\newpage
\subsubsection*{Author Contributions}
Left blank for anonymity reason.
% If you'd like to, you may include a section for author contributions as is done
% in many journals. This is optional and at the discretion of the authors.

\subsubsection*{Acknowledgments}
Left blank for anonymity reason.

%We thank Pierre Vandergheynst for advices, and Andreas Loukas for having processed the GHCN data.
%We thank Taco Cohen for his inputs on the intriguing results of our comparison with \citet{cohen2019gauge}.
%We used the Python Graph Signal Processing package (PyGSP) \citep{pygsp} for computations and plots.
%The Python Graph Signal Processing package (PyGSP) \citep{pygsp} was used to build graphs, compute the Laplacian and Fourier basis, and perform graph convolutions.

\bibliography{references}
\bibliographystyle{iclr2020_conference}

\newpage
{\LARGE \sc {Supplementary Material}}
\appendix

\section{Proof of theorem \ref{theo:pointwise convergence for a regular sampling}}\label{sec: appendix: proof of theorem}

\paragraph{Preliminaries.}
The proof of theorem \ref{theo:pointwise convergence for a regular sampling} is inspired from the work of \cite{belkin2005towards}. As a result, we start by restating some of their results.
Given a sampling $V = \{x_i\in\mathcal M\}_{i=0}^{n-1}$ of a closed, compact and infinitely differentiable manifold $\mathcal{M}$, a smooth ($\in\mathcal{C}_\infty(\mathcal{M)}$) function  $f:\mathcal{M} \rightarrow \mathbb{R}$, and defined the vector $\b{f}$ of samples of $f$ as follows: $T_\V f = \b{f} \in \mathbb{R}^n,\ \b{f}_i = f(x_i)$.
The proof is constructed by leveraging 3 different operators:
\begin{itemize}
    \item The extended graph Laplacian operator is a functional $L_n^t: L^{2}(\mathcal{M}) \rightarrow L^{2}(\mathcal{M})$  is defined given a sampling $\{x_i\in\mathcal M\}_{i=0}^{n-1}$ and $y\in \mathcal{M}$  as
	\begin{equation}
	\label{eq:Heat Kernel Graph Laplacian operator}
	 L_n^tf(y) := \frac{1}{n}\sum_{i=0}^{n-1} e^{ -\frac{\|x_i-y\|^2}{4t}} \left(f(y)-f(x_i)\right).
	\end{equation}
	Note that we have the following relation $\b{L}_n^t \b{f} = T_\V L_n^t f$.
	\item The functional approximation to the Laplace-Beltrami operator is a functional $L^t: L^{2}(\mathcal{M}) \rightarrow L^{2}(\mathcal{M})$ defined  as
	\begin{equation}
    \label{eq:Functional approximation to the Laplace-Beltrami operator}
	L^tf(y) = \int_{\mathcal{M}} \exp^{-\frac{\|y-x\|^2}{4t}}\left(f(y)-f(x)\right)d\mu(x),
	\end{equation}
	where given $\mu$ be the uniform probability measure on the manifold $\mathcal{M}$, and let $\text{vol}(\mathcal{M})$ be the volume of $\mathcal{M}$.
	\item
	The Laplace-Beltrami operator $\Delta_{\mathcal{M}}$ is defined as the divergence of the gradient
	\begin{equation}
        \label{eq:laplace-beltrami}
        \Delta_{\mathcal M}f(y):= -\text{div}(\nabla_{\mathcal M}f)
    \end{equation}
    of a differentiable function $f: \mathcal M\rightarrow \R$. The gradient $\nabla f: \mathcal M \rightarrow T_p\mathcal M$ is a vector field defined on the manifold pointing towards the direction of steepest ascent of $f$, where $T_p\mathcal M$ is the affine space of all vectors tangent to $\mathcal M$ at $p$

\end{itemize}

Leaveraging these three operators \cite{belkin2005towards, belkin2007convergence} have build proofs of both pointwise and spectral convergence of the extended graph Laplacian toward the Laplace-Beltrami operator.
The proofs consists in establishing that \eqref{eq:Heat Kernel Graph Laplacian operator} converges toward \eqref{eq:Functional approximation to the Laplace-Beltrami operator} as $n\rightarrow \infty$ and \eqref{eq:Functional approximation to the Laplace-Beltrami operator} converges toward \eqref{eq:laplace-beltrami} as $t\rightarrow 0$. In particular, this second step is given by the following:
\begin{prop}
[\cite{belkin2005towards}, Proposition 4.4]
Let $\mathcal{M}$ be a $k$-dimensional compact smooth manifold embedded in some Euclidean space $\mathbb{R}^N$, and fix $y\in\mathcal{M}$. Let $f\in\mathcal{C}_\infty(\mathcal{M)}$. Then
\begin{equation}
\frac{1}{t}\frac{1}{(4\pi t)^{k/2}} L^tf(y) \xrightarrow{t\to 0 } \frac{1}{\text{vol}(\mathcal M)}\Delta_{\mathcal M}f(y).
\end{equation}
\label{prop:3}
\end{prop}

\paragraph{Building the proof.}
As the sphere is a compact smooth manifold embedded in $\mathbb{R}^3$, we can reuse proposition \ref{prop:3}. Thus, our strategy to prove Theorem \ref{theo:pointwise convergence for a regular sampling} is to a) show that
\begin{equation}\label{eq:continuous convergence}
 \lim_{n\to\infty}L_n^{t} f(y) =  L^t(y)
\end{equation}
for a particular class of sampling and b) apply Proposition \ref{prop:3}.


%  \frac{|\mathbb{S}^2|}{4\pi t}
% \begin{definition}{}\\
% 	\label{def:Heat Kernel Graph Laplacian operator}
% 	\text{Given a sampling $\{x_i\in\mathcal M\}_{i=0}^{n-1}$ of the manifold we define the \textbf{operator} }$L_n^t$ such that
% 	$$L_n^tf(y) := \frac{1}{n}\left[ \sum_{i=0}^{n-1} \exp \left\{ {-\frac{||x_i-y||^2}{4t}}\right\}\left(f(y)-f(x_i)\right)\right]$$
% \end{definition}

% it is known that  (\cite{belkin2005towards}) to prove the convergence of $(\b {L}_n^t \b f) _i$ to $\Delta_{\S^2}f(x_i)$ it is sufficient to prove the convergence of its continuous counterpart $L_n^tf(x)$ to $\Delta_{\S^2}f(x)$
% where $L_n^t$ is defined as follows:

% For the sake of the proof we will need also the following facts:
% \begin{definition}{} (\cite{belkin2005towards})\\ \label{eq: my L^t} Let $\mu$ be the uniform probability measure on the manifold $\mathcal M$, and let $\text{vol}(\mathcal M)$ be the volume of $\mathcal M$. We define the functional approximation to the Laplace-Beltrami operator to be the operator $L^t: L^{2}(\mathcal{M}) \rightarrow L^{2}(\mathcal{M})$ such that
% 	\label{def:Functional approximation to the Laplace-Beltrami operator}
% 	$$ L^tf(y) = \int_{\mathcal M}\exp\left\{-\frac{||y-x||^2}{4t}\right\}\left(f(y)-f(x)\right)d\mu(x)$$
% \end{definition}

% brief introduction:
% This proof consists in two steps: first, we prove that $L_n^t \rightarrow L^t$, and second, we use proposition \ref{prop:3} to prove \eqref{eq:continuous convergence}. This equation, as already explained in \cite{belkin2007convergence}, directly implies theorem \ref{theo:pointwise convergence for a regular sampling}.

We start by proving that for smooth functions, the sum converges toward an integral as the sampling increase in size.
\begin{prop}\label{prop:1}
	For an equal area sampling $\{x_i\in\S^2\}_{i=0}^{n-1}: A_i=A_j \forall i,j$ of the sphere it is true that for all $f: \S^2 \rightarrow \R$ Lipschitz with respect to the Euclidean distance $\|\cdot\|$ with Lipschitz constant $C_f$
	\begin{equation*}
	\left| \int_{\S^2}f({ x})\text{d}{\mu(x)} - \frac{1}{n}\sum_i f( x_i)\right|\leq \mathcal L_fd^{(n)}.	    
	\end{equation*}
	Furthermore, for all $y\in\S^2$ the Heat Kernel Graph Laplacian operator $L^t_n$ converges pointwise to the functional approximation of the Laplace Beltrami operator $L^t$
	\begin{equation*}
	 L_n^tf(y)\xrightarrow{n\to\infty} L^tf(y).
	\end{equation*}
\end{prop}
\begin{proof}
\nati{@martino, the function should be from $\S^2$ instead of $\R^3$ here right? }
	Assuming $f:\R^3\rightarrow \R$ is Lipschitz with Lipschitz constant $C_f$, we have
	\begin{equation*}
	\left| \int_{\sigma_{i}}f({ x})\text{d}{\mu(x)} - \frac{1}{n}f( x_i)\right| \leq C_fd^{(n)}\frac{1}{n},	    
	\end{equation*}
	where $\sigma_i\in \S^2$ is the subset of the sphere corresponding to the patch arround $x_i$. Remember that the sampling is equal area.
	Hence, using the triangular inequality and summing all the contributions of the $n$ patches, we obtain
	\begin{equation*}
	\left| \int_{\S^2}f({ x})\text{d}{\mu(x)} - \frac{1}{n}\sum_i f( x_i)\right| \leq \sum_i \left| \frac{1}{4\pi^2} \int_{\sigma_{i}}f({ x})\text{d}{\mu(x)} - \frac{1}{n}f( x_i)\right|\leq n  C_fd^{(n)}\frac{1}{n} = C_fd^{(n)}
	\end{equation*}
	A direct application of this result leads to the following pointwise convergences
	\begin{equation*}
	\forall f \text{ Lipschiz,}\quad \forall y\in\S^2,  \quad\quad \frac{1}{n}\sum_i e^{-\frac{\|x_i-y\|^2}{4t}}\rightarrow   \int e^{-\frac{\|x-y\|^2}{4t}}d\mu(x) 
	\end{equation*}
    \begin{equation*}
    \forall f \text{ Lipschiz,}\quad \forall y\in\S^2,  \quad\quad \frac{1}{n}\sum_i e^{-\frac{||x_i-y||^2}{4t}}f(x_i)\rightarrow   \int e^{-\frac{\|x-y\|^2}{4t}}f(x)d\mu(x)        
    \end{equation*}
	Definitions \ref{eq:Heat Kernel Graph Laplacian operator} and \ref{eq:Functional approximation to the Laplace-Beltrami operator} end the proof.
\end{proof}

The last proposition show that for a \emph{fixed} $t$, $L_n^tf(x)\rightarrow \linefrac{1}{4\pi^2} L^tf(x)$. To utilize Proposition \ref{prop:3} and complete the proof, we need to find a sequence of $t_n$ for which this holds as $t_n \rightarrow 0$. Furthermore this should hold with a faster decay than $\frac{1}{4\pi t_n^2}$.
\begin{prop}\label{prop:2}
	Given a sampling regular enough, i.e., for which we assume $A_i=A_j \ \forall i,j\text{ and }d^{(n)}\leq \frac{C}{\sqrt{n}}$, a Lipschitz function $f$ and a point $y\in\S^2$ there exists a sequence $t_n = n^\beta, \beta<0$ such that
\begin{equation*}
    \forall f \text{ Lipschitz, } \forall x\in\S^2 \quad \left|\frac{1}{4\pi t_n^2}\left(L_n^{t_n}f(x) -  L^{t_n}f(x)\right)\right|\xrightarrow{n\to \infty}0.
\end{equation*}
\end{prop}
\begin{proof}
% [Proof of Proposition \ref{prop:2}]
To ease the notation, we define
\begin{align}
	K^t(x,y) &:=  e^{-\frac{\|x-y\|^2}{4t}}\\
	\phi^t(x;y) &:= e^{-\frac{\|x-y\|^2}{4t}}\left(f(y)-f(x)\right).
\end{align}
We start with the following inequality
\begin{align}
	\|L_n^tf-L^tf\|_\infty &= \max _{y\in \S^2} \left|L_n^tf(y)-L^tf(y)\right| \nonumber\\
	&= \max _{y\in \S^2} \left| \frac{1}{n} \sum_{i=1}^n \phi^t(x_i; y)- \int_{\S^2} \phi^t(x;y)d\mu(x) \right| \nonumber\\
	&\leq \max _{y\in \S^2}  \sum_{i=1}^n   \left| \frac{1}{n}  \phi^t(x_i; y)- \int_{\sigma_i} \phi^t(x;y)d\mu(x) \right| \nonumber\\
	&\leq  d^{(n)} \max _{y\in \S^2} C_{\phi^t_y} , \label{eq:prop3-base-ineq}
\end{align}
where $C_{\phi^t_y}$ is the Lipschitz constant of $x \rightarrow \phi^t(x, y)$ and the last inequality follows from Proposition \ref{prop:1}. 
Using the assumption $d^{(n)}\leq \frac{C}{\sqrt{n}}$ we find
\begin{equation*}
\|L_n^tf-L^tf\|_\infty  \leq  \frac{C}{\sqrt{n}} \max _{y\in \S^2}  C_{\phi^t_y}  
\end{equation*}
We now find the explicit dependence between $t$ and $C_{\phi^t_y}$
\begin{align*}
	C_{\phi^t_y} &= \|\partial_x\phi^t(\cdot;y)|\_\infty\\&
	= \|\partial_x\left(K^t(\cdot;y)f\right)\|_\infty\\&
	= \|\partial_x K^t(\cdot;y)f + K^t(\cdot;y)\partial_x f||_\infty\\&
	\leq \|\partial_x K^t(\cdot;y)f\|_\infty + \|K^t(\cdot;y)\partial_x f\|_\infty\\&
	\leq  \|\partial_x K^t(\cdot;y)\|_\infty\|f\|_\infty + \|K^t(\cdot;y)\|_\infty\|\partial_x f\|_\infty\\&
	= \|\partial_x K^t(\cdot;y)\|_\infty\|f\|_\infty + \|\partial_x f\|_\infty\\&
	= C_{K^t_y} \|f\|_\infty + \|\partial_xf\|_\infty\\&
	= C_{K^t_y} \|f\|_\infty + C_f
\end{align*}
where $C_{K^t_y}$ is the Lipschitz constant of the function $x\rightarrow K^t(x;y)$. We note that this constant does not depend on $y$:
\begin{equation*}
C_{K^t_y} = \norm{\partial_x e^{-\frac{x^2}{4t}}}_\infty = \norm{\frac{x}{2t}e^{-\frac{x^2}{4t}}}_\infty = \left. \frac{x}{2t}e^{-\frac{x^2}{4t}}\right|_{x=\sqrt{2t}}=(2et)^{-\frac{1}{2}}\propto t ^ {-\frac{1}{2}}.
\end{equation*}
Hence we have
\begin{align*}
	\frac{C}{\sqrt{n}}  \max _{y\in \S^2} C_{\phi^t_y} 
	&\leq  \frac{C}{\sqrt{n}} \left( (2et)^{-\frac{1}{2}} \norm{f}_\infty + C_f \right)\\
	&\leq \frac{C \norm{f}_\infty}{\sqrt{n}(2et)^{1/2}} +   \frac{C}{\sqrt{n}} C_f.
\end{align*}
Inculding this result in \eqref{eq:prop3-base-ineq} and rescaling by $\linefrac{1}{4\pi t^2}$, we obtain
\begin{align*}
	\norm{\frac{1}{4\pi t^2}\left(L_n^tf-L^tf\right)}_\infty&\leq \frac{1}{4\pi t^2}\norm{\left(L_n^tf-L^tf\right)}_\infty \\
	&\leq \frac{C}{4\pi}\left[\frac{\norm{f}_\infty}{\sqrt{2e}}\frac{1}{\sqrt{n}t^{5/2}} + \frac{C_f}{\sqrt{n}t^2}\right].
\end{align*}
In order for $ \frac{C}{4\pi}\left[\frac{\norm{f}_\infty}{\sqrt{2e}}\frac{1}{\sqrt{n}t^{5/2}} + \frac{C_f}{\sqrt{n}t^2}\right] \xrightarrow[t\to 0 ]{n\to\infty}0$, 
we need $\begin{cases}
% t \rightarrow 0\\
% n \rightarrow \infty\\
\sqrt{n}t^{5/2} \rightarrow \infty\\
\sqrt{n}t^2 \rightarrow \infty
\end{cases}$ \\
It happens if $\begin{cases}
t(n) = n^\beta, &\beta\in(-\frac{1}{5}, 0) \\
t(n) = n^\beta, &\beta\in(-\frac{1}{4}, 0)
\end{cases} \implies t(n) = n^\beta, \quad \beta\in(-\frac{1}{5}, 0)$.\\
Indeed, we have\\
$\sqrt{n}t^{5/2}=n^{5/2\beta+1/2}\xrightarrow{n \to \infty} \infty$ since $\frac{5}{2}\beta+1/2>0 \iff \beta>-\frac{1}{5}$\\
and $\sqrt{n}t^2=n^{2\beta+1/2}\xrightarrow {n \to \infty} \infty$ since $2\beta+1/2>0 \iff \beta>-\frac{1}{4}$.\\
As a result, for $t=n^\beta$ with $\beta\in(-\frac{1}{5}, 0)$ we have
$\begin{cases}
(t_n)\xrightarrow{n\to\infty}0\\
\norm{\frac{1}{4\pi t_n^2}L_n^{t_n}f-\frac{1}{4\pi t_n^2}L^{t_n}f}_\infty  \xrightarrow{n\to\infty}0,
\end{cases}$\\
which concludes the proof.
\end{proof}

Theorem  \ref{theo:pointwise convergence for a regular sampling}, is then an immediate consequence of Proposition \ref{prop:2} and \ref{prop:3}.
\begin{proof}[Proof of Theorem \ref{theo:pointwise convergence for a regular sampling}]
	Thanks to Proposition \ref{prop:2} and Proposition \ref{prop:3}	we conclude that $\forall y\in\S^2 $
	\begin{equation*}
	\lim_{n\to\infty}\frac{1}{4\pi t_n^2} L_n^{t_n}f(y) =  \lim_{n\to\infty}\frac{1}{4\pi t_n^2} L^{t_n}f(y) = \frac{1}{|\S^2|}\triangle_{\S^2}f(y)
	\end{equation*}
	Eventually selecting $y$ as a point of the sampling, we obtain
	\begin{equation*}
	 \lim_{n\to\infty} \frac{|\mathbb{S}^2|}{4\pi t_n^2} \b{L}_n^{t_n} T_V f [i] =  \Delta_{\mathbb{S}^2}f(x_i)\quad \forall i=0, ..., n-1.
	\end{equation*} 
\end{proof}

\nati{@martino, actually we do not need $ d^{(n)}\leq \frac{1}{\sqrt{n}}$, we only need $ d^{(n)}\leq \frac{1}{n^\alpha}$, where $\alpha>0$. As the $\S^2$ is of dimension $2$, $\alpha$ cannot be larger than $\linefrac{1}{2}$. If we put that into the theorem, we obtain that $\frac{5}{2}\beta+\alpha>0 \iff \beta>-\frac{2\alpha}{5}$. I think this is important, because we can still have convergence even if we do not have perfect patches... Please confirm ASAP, so we can update the Proposition and the text bellow. For HealPix sampling, we could say that while we have not proof, it make sense that it statisfies the hypothesis probably with $\alpha=\linefrac{1}{2}$.}

The proof of Proposition \ref{prop:2} is instructive. First, we note that some regularity conditions on the sampling are needed. If the sampling is equal area as HEALPix, meaning that all the patches $\sigma_i$ have the same area, then we need to impose that $ d^{(n)}\leq \frac{1}{\sqrt{n}}$. \\
In the work of \cite{belkin2005towards} the sampling is drawn form a uniform random distribution on the sphere, and their proof heavily relies on the uniformity properties of the distribution from which the sampling is drawn. In our case the sampling is deterministic, and the fact that for a sphere there doesn't exist a regular sampling with more than 12 points (the vertices of a icosahedron) is indeed a problem that we need to overcome by imposing the regularity conditions above.

To conclude, we can see that the result obtained has the same form than the result obtained in \cite{belkin2005towards}. Given the kernel density $t(n)=n^\beta$, if Belkin et al. proved convergence in the random case for $\beta \in (-\frac{1}{4}, 0)$, we proved convergence in the deterministic case for $\beta \in (-\frac{1}{5}, 0)$. This kind of result can be interpreted in the following way. In order to have this pointwise convergence, we need to reduce the kernel width but \emph{not so fast} compared to the resolution of the graph. In other words, the kernel width has to be reduced but is somewhat limited by the resolution of the graph.


\section{Experimental details}

\subsection{3D objects recognition}

\Tabref{shrec17_retrieval} shows the results obtained from the competition's official evaluation script.
\Tabref{modelnet40} shows results on ModelNet40.

\begin{table}
    \centering
	\scriptsize
    \begin{tabular}{l cccc cccc}
    & \multicolumn{4}{c}{micro (label average)} & \multicolumn{4}{c}{macro (instance average)} \\
	\cmidrule(lr){2-5} \cmidrule(lr){6-9}
    & P@N & R@N & F1@N & mAP & P@N & R@N & F1@N & mAP \\
	\toprule
    \citet{cohen2018sphericalcnn} ($b=128$) & 0.701 & 0.711 & 0.699 & 0.676 & - & - & - & - \\
    \citet{cohen2018sphericalcnn} (simplified, $b=64$) & 0.704 & 0.701 & 0.696 & 0.665 & 0.430 & 0.480 & 0.429 & 0.385 \\
    \citet{esteves2018sphericalcnn} ($b=64$) & 0.717 & 0.737 & - & 0.685 & 0.450 & 0.550 & - & 0.444 \\
    DeepSphere (equiangular $b=64$) & 0.709 & 0.700 & 0.698 & 0.665 & 0.439 & 0.489 & 0.439 & 0.403 \\
    DeepSphere (HEALPix $N_{side}=32$) & 0.725 & 0.717 & 0.715 & 0.686 & 0.475 & 0.508 & 0.468 & 0.428\\
	\bottomrule
    \end{tabular}
    \caption{Official metrics from the SHREC'17 object retrieval competition.}
    \label{tab:shrec17_retrieval}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{l cccc}
	\toprule
    & no/no & z/z & SO3/SO3 & z/SO3 \\
	\midrule
	\citet{cohen2018sphericalcnn} & 85.0 & - & - & - \\
	\citet{jiang2019sphericalcnn} & 90.5 & - & - & - \\
	\citet{esteves2018sphericalcnn} & - & 88.9 & 86.9 & 76.7 \\
	%Esteves \emph{MVCNN} & 94.69 & - & - & - \\
	DeepSphere & 87.8 & 86.8 & 86.7 & 76.9 \\
	\bottomrule
    \end{tabular}
    \caption{
		Accuracy results on ModelNet40.
		``no'' denotes no augmentation, ``z'' is augmented with rotations around the Z-axis, and ``SO3'' with ZYZ rotations.
		\todo{The first is training time augmentation, the second test time augmentation.}
	}
    \label{tab:modelnet40}
\end{table}

\begin{dmath}
    [GC_{16}\, +\, BN\, +\, ReLU]_{nside32}\, +\, \textrm{Pool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{nside16}\, +\, \textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{nside8}\, +\, \textrm{Pool}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{nside4}\, +\,\textrm{Pool}\, +\, [GC_{256}\, +\, BN\, +\, ReLU]_{nside2}\, +\, \textrm{Pool}\, +\, GAP\, +\, FCN\, +\, \textrm{softmax}
\end{dmath}

\subsection{Cosmological model classification}

\begin{dmath}
    [GC_{16}\, +\, BN\, +\, ReLU]_{nside1024}\, +\, \textrm{Pool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{nside512}\, +\, \textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{nside256}\, +\, \textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{nside128}\, +\,\textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{nside64}\, +\, \textrm{Pool}\, +\, [GC_{2}]_{nside32}\, +\, GAP\, +\, \textrm{softmax}
\end{dmath}

\subsection{Climate event segmentation} \label{sec:climate:appendix}

\Tabref{climate:accuracy}, \ref{tab:climate:map}, and \ref{tab:climate:speed} show the accuracy, mAP, and efficiency of all the NNs we ran.

* Jiang rerun with a batch size of 64 instead of 256 due to memory limit.\\
* DS-jiang is the similar architecture as \cite{jiang2019sphericalcnn}. \\
* DS-optimal has 2 times the number of feature maps of DS. \\
* \todo{What is DS and DS-Cohen?} DS has 4 times more feature maps and one more layer than DS-Jiang. DS-optimal has still 2 times more feature maps. DS-Cohen should be mostly gauge (based on paper, no code): 4 times more feature maps, but 2 layers less than DS-Jiang. \\
* \todo{Is (equi non-weighted) the full resolution?} Yes, but less feature maps and layers. Can run, but not enough GPU memory for an optimal architecture. \\
* \todo{check column order for DS} \\
* perf with same arch as Jiang in appendix => not enough channels!\\
* even more feature maps give us one more point in perf\\

% trade off between AP and accuracy in the case of TC class, it seems.\\
% (full: we scale (50B pixels, 20TB) $\Rightarrow$ lead to better perf?)
% full dataset not enough memory to run a correct model

\begin{table}
    \centering
	\begin{tabular}{l l l l l}
		\toprule
        & TC & AR & BG & mean \\
		\midrule
		\cite{mudigonda2017climateevents} & 74 & 65 & 97 & 78.67 \\
		\cite{jiang2019sphericalcnn} (paper) & 94 & 93 & 97 & 94.67 \\
		\cite{jiang2019sphericalcnn} (rerun) & 93.9 & 95.7 & 95.2 & 94.95 \\
        \cite{cohen2019gauge} (S2R) & 97.8 & 97.3 & 97.3 & 97.5 \\
        \cite{cohen2019gauge} (R2R) & 97.9 & 97.8 & 97.4 & 97.7 \\
		\midrule
		DS (Jiang architecture, weighted loss) & 97.1 & 97.6 & 96.5 & 97.1 \\
        DS (weighted loss) & $97.4\pm 1.1$ & $97.7\pm 0.7$ & $98.2\pm 0.5$ & $97.8\pm 0.3$ \\
		DS (wider architecture, weighted loss) & 91.5 & 93.4 & 99.0 & 94.6 \\
		\midrule
        DS (Jiang architecture, non-weighted loss) & 33.6 & 93.6 & 99.3 & 75.5 \\
        DS (non-weighted loss) & $69.2\pm 3.7$ & $94.5\pm 2.9$ & $99.7\pm 0.1$ & $87.8\pm 0.5$ \\
        DS (wider architecture, non-weighted loss) & 73.4 & 92.7 & 99.8 & 88.7 \\
		\midrule
		\todo{DS (Cohen architecture, weighted loss)} & 95.5 & 96.9 & 93.9 & 95.4 \\
		\todo{DS (Cohen architecture, non-weighted loss)} & 56.4 & 90.0 & 98.9 & 81.8 \\
		\todo{DS (full dataset, non-weighted loss)} & 31.3 & 75.2 & 99.9 & 68.80 \\
		\bottomrule
    \end{tabular}
    \caption{
		Results on climate event segmentation: accuracy.
		Tropical cyclones (TC) and atmospheric rivers (AR) are the two positive classes, against the background (BG).
		\todo{\citet{mudigonda2017climateevents} is not directly comparable as they don't use the same input feature maps.}
		Note that a non-weighted cross-entropy loss is not optimal for the accuracy metric.
		\label{tab:climate:accuracy}
	}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{l l l l}
		\toprule
        & TC & AR & mean \\
		\midrule
		\cite{jiang2019sphericalcnn} (rerun) & 11.08 & 65.21 & 38.41 \\
        \cite{cohen2019gauge} (S2R) & - & -& 68.6 \\
        \cite{cohen2019gauge} (R2R) & - & -& 75.9 \\
		\midrule
        DS (Jiang architecture, non-weighted loss) & 46.2 & 93.9 & 70.0 \\
        DS (non-weighted loss) & $80.86\pm 2.42$ & $97.45\pm 0.38$ & $89.16\pm 1.37$ \\
        DS (wider architecture, non-weighted loss) & 84.71 & 98.05 & 91.38 \\
		\midrule
        DS (Jiang architecture, weighted loss) & 49.7 & 89.2 & 69.5 \\
        DS (weighted loss) & $58.88\pm 3.17$ & $95.41\pm 1.51$ & $77.15\pm 1.94$ \\
        DS (wider architecture, weighted loss) & 52.80 & 94.78 & 73.79 \\
		\midrule
		\todo{DS (Cohen architecture, weighted loss)} & 13.1 & 80.3 & 46.7 \\
		\todo{DS (Cohen architecture, non-weighted loss)} & 59.8 & 85.0 & 72.4 \\
		\todo{DS (full dataset, non-weighted loss)} & 55.53 & 94.85 & 75.19 \\
		\bottomrule
    \end{tabular}
    \caption{
		Results on climate event segmentation: average precision.
		Tropical cyclones (TC) and atmospheric rivers (AR) are the two positive classes.
		Note that a weighted cross-entropy loss is not optimal for the average precision metric.
	}
		\label{tab:climate:map}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{l r r r}
		\toprule
		& \multicolumn{1}{c}{size} & \multicolumn{2}{c}{speed} \\
        \cmidrule(lr){2-2} \cmidrule(lr){3-4}
		& params & inference & training \\
		\midrule
        %Mudigonda et al. & 97 & 74 & 65 & 78.67 & - & - & - \\
		\cite{jiang2019sphericalcnn} & 330\,k & 10\,ms & 10\,h \\ % 328'339
		% \cite{cohen2019gauge} (S2R) & - & - & - \\
        % \cite{cohen2019gauge} (R2R) & - & - & - \\
		DeepSphere (Jiang architecture) & 590\,k & 5\,ms & 3\,h \\ % 590k
        DeepSphere & 13\,M & 33\,ms & 13\,h \\ % 12'926'432
		DeepSphere (wider architecture) & 52\,M & 50\,ms & 20\,h \\
		\todo{DS (Cohen architecture)} & 2\,M & 11\,ms & 4\,h \\
		\todo{DS (full dataset)} & - & 567\,ms & 48\,h \\
		\bottomrule
    \end{tabular}
    \caption{
		Results on climate event segmentation: size and speed.
	}
		\label{tab:climate:speed}
\end{table}

\subsubsection*{DS Icosahedron architecture}

icosahedron sampling, level-5 resolution

CNN with encoder decoder architecture
encoder:\\
\begin{dmath}
    [GC_{32}\, +\, BN\, +\, ReLU]_{L5}\,+\, [GC_{64}\, +\, BN\, +\, ReLU]_{L5}\, +\, \textrm{Pool}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L4}\, +\, \textrm{Pool}\, +\, [GC_{256}\, +\, BN\, +\, ReLU]_{L3}\, +\,\textrm{Pool}\, +\, [GC_{512}\, +\, BN\, +\, ReLU]_{L2} +\,\textrm{Pool}\, +\, [GC_{512}\, +\, BN\, +\, ReLU]_{L1} +\,\textrm{Pool}\, +\, [GC_{512}]_{L0}
\end{dmath}
decoder:\\
\begin{dmath}
    \textrm{Unpool}\, +\,[GC_{512}\, +\, BN\, +\, ReLU]_{L1}\, +\, \textrm{concat}\, +\, [GC_{512}\, +\, BN\, +\, ReLU]_{L1}\, +\, \textrm{Unpool}\, +\, [GC_{256}\, +\, BN\, +\, ReLU]_{L2}\, +\, \textrm{concat}\, +\, [GC_{256}\, +\, BN\, +\, ReLU]_{L2}\, +\, \textrm{Unpool}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L3}\, +\, \textrm{concat}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L3}\, +\,\textrm{Unpool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{L4}\,+\, \textrm{concat}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{L4}\, +\,\textrm{Unpool}\,  +\, [GC_{32}\, +\, BN\, +\, ReLU]_{L5}\,+ \, [GC_3]_{L5}
\end{dmath}
% number of parameters: 2,2M

concat the results of the corresponding encoder layer before the graph convolution. Not similar to Jiang and 4 times the feature maps.

batch size 64, adam optimizer, constant learning rate of $1 \cdot 10{-3}$, cross-entropy loss, both weighted and non weighted. Weight chosen with scikit-learn "compute\_class\_weight" on the training set

30 epochs

wider architecture is the same, but with 2 time the feature maps.
\subsubsection*{DS (Jiang architecture)}
encoder:\\
\begin{dmath}
    [GC_{8}\, +\, BN\, +\, ReLU]_{L5}\,+\,\textrm{Pool}\,+\, [GC_{16}\, +\, BN\, +\, ReLU]_{L4}\, +\, \textrm{Pool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{L3}\, +\, \textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{L2}\, +\,\textrm{Pool}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L1}\, +\, \textrm{Pool}\,  +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L0}
\end{dmath}
decoder:\\
\begin{dmath}
    \textrm{Unpool}\, +\,[GC_{128}\, +\, BN\, +\, ReLU]_{L1}\, +\, \textrm{concat}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{L1}\, +\, \textrm{Unpool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{L2}\, +\, \textrm{concat}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{L2}\, +\, \textrm{Unpool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{L3}\, +\, \textrm{concat}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{L3}\, +\,\textrm{Unpool}\, +\, [GC_{16}\, +\, BN\, +\, ReLU]_{L4}\,+\, \textrm{concat}\, +\, [GC_{16}\, +\, BN\, +\, ReLU]_{L4}\, +\,\textrm{Unpool}\,  +\, [GC_{8}\, +\, BN\, +\, ReLU]_{L5}\,+\,\textrm{concat}\, +\, [GC_{8}\, +\, BN\, +\, ReLU]_{L5}\, + \,[GC_3]_{L5}
\end{dmath}
% number of parameters: 590'976  % more feat is 16 times more

concat the results of the corresponding encoder layer after the graph convolution. Similar to ``Jiang et al.''
\subsubsection*{Full dataset - Equiangular architecture}
Equiangular sampling, with a latitude bandwidth 384 and longitude bandwidth 576.

Due to memory problem, could not use the same architecture

8 epochs

encoder:\\
\begin{dmath}
    [GC_{16}\, +\, BN\, +\, ReLU]_{bw}\,+\, [GC_{16}\, +\, BN\, +\, ReLU]_{bw}\, +\, \textrm{Pool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{bw/16}\, +\, \textrm{Pool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{bw/64}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{bw/64}
\end{dmath}
decoder:\\
\begin{dmath}
    \textrm{Unpool}\, +\,[GC_{128}\, +\, BN\, +\, ReLU]_{bw/64}\, +\, \textrm{concat}\, +\, [GC_{128}\, +\, BN\, +\, ReLU]_{bw/64}\, +\, \textrm{Unpool}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{bw/64}\, +\, \textrm{concat}\, +\, [GC_{64}\, +\, BN\, +\, ReLU]_{bw/64}\, +\, \textrm{Unpool}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{bw/16}\, +\, \textrm{concat}\, +\, [GC_{32}\, +\, BN\, +\, ReLU]_{bw/16}\, +\,\textrm{Unpool}\, +\, [GC_{16}\, +\, BN\, +\, ReLU]_{bw}\,+\, \textrm{concat}\, +\, [GC_{16}\, +\, BN\, +\, ReLU]_{bw}\, +\,\textrm{Unpool}\,  +\, [GC_{16}\, +\, BN\, +\, ReLU]_{bw}\,+\,[GC_3]_{bw}
\end{dmath}

batch size 1

\subsection{Uneven sampling}

Architecture for dense regression:
\begin{dmath}
    [GC_{50}\, +\, BN\, +\, ReLU]\, +\, [GC_{100}\, +\, BN\, +\, ReLU]\, +\, [GC_{100}\, +\, BN\, +\, ReLU]\, +\, [GC_{1}]
\end{dmath}

Architecture for global regression:
\begin{dmath}
    [GC_{50}\, +\, BN\, +\, ReLU]\, +\, [GC_{100}\, +\, BN\, +\, ReLU]\, +\, [GC_{100}\, +\, BN\, +\, ReLU]\, +\, GAP\, +\, FCN
\end{dmath}

\end{document}
